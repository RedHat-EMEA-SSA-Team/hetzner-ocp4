---
- name: Retrieve first public key fingerprint
  uri:
    url: "{{ robot_base }}/key"
    return_content: yes
    method: GET
    user: "{{ hetzner_webservice_username }}"
    password: "{{ hetzner_webservice_password }}"
    force_basic_auth: yes
    status_code: 200
  register: key
  delegate_to: localhost

### todo: add mechanism to check FP of key with the one give by hetzner_ssh_private_id parameter
# Sadly, Hetzner provided fingerprint in:
# "key": {
#     "created_at": "2020-12-18T14:59:49.000Z",
#     "data": "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAOfl+764UFbDkkxpsQYjET7ZAWoVApSf4I64L1KImoc rbohne@redhat.com",
#     "fingerprint": "cb:fc:61:a3:de:48:2a:fc:5e:75:14:b6:0a:36:d9:1f",
#     "name": "AA-ed25519",
#     "size": 256,
#     "type": "ED25519"
# }
# Ansible module community.crypto.openssh_keypair in SHA356
#   - name: Check OpenSSH private key
#     community.crypto.openssh_keypair:
#       regenerate: never
#       path: "{{ hetzner_ssh_private_id }}"
#     register: ssh_private_key
#   - debug:
#       var: ssh_private_key
# =>  "fingerprint": "SHA256:MV6mnlC44jtntBj327ya7mump58SUJQDzzAmlJxnMkM",

- name: Set authorized_key fact
  set_fact:
    authorized_key: "{{ key.json[0].key.fingerprint }}"

- name: "Retrieve server number from IP {{ hetzner_ip }}"
  uri:
    url: "{{ robot_base }}/server"
    return_content: yes
    method: GET
    user: "{{ hetzner_webservice_username }}"
    password: "{{ hetzner_webservice_password }}"
    force_basic_auth: yes
    status_code: 200
  register: servers
  delegate_to: localhost

- name: Filter server by IPv4 or IPv6
  delegate_to: localhost
  set_fact:
    # yamllint disable rule:line-length
    server_id_list: "{{ servers.json | to_json | from_json | community.general.json_query('[?cancelled == false && status == \"ready\" && ( server.server_ip ==  `'~ hetzner_ip ~'` || contains(`'~ hetzner_ip ~'`, server.server_ipv6_net) ) ].server.server_number')  }}"
    # yamllint enable rule:line-length

- name: Check server_id
  delegate_to: localhost
  ansible.builtin.fail:
    msg: "Can NOT find Hetzner Server Id, to many or no matching server found."
  when: server_id_list|length != 1

- name: Filter server by IPv4 or IPv6
  delegate_to: localhost
  set_fact:
    server_id: "{{ server_id_list | first }}"

- name: Check rescue mode
  uri:
    url: "{{ robot_base }}/boot/{{ server_id }}/rescue"
    method: GET
    user: "{{ hetzner_webservice_username }}"
    password: "{{ hetzner_webservice_password }}"
    force_basic_auth: yes
    status_code: 200
  register: rescue
  delegate_to: localhost

- name: Activate rescue mode
  uri:
    url: "{{ robot_base }}/boot/{{ server_id }}/rescue"
    method: POST
    user: "{{ hetzner_webservice_username }}"
    password: "{{ hetzner_webservice_password }}"
    force_basic_auth: yes
    body: "os=linux&arch=64&authorized_key={{ authorized_key }}"
    status_code: 200
    headers:
      Content_Type: "application/x-www-form-urlencoded"
  register: activated
  delegate_to: localhost
  when:
    - not rescue.json.rescue.active
    - not already_in_rescue

# - debug: msg="{{ activated }}"

- name: Pause a bit to allow rescue mode to settle
  pause: seconds=5

- name: Execute hardware reset
  uri:
    url: "{{ robot_base }}/reset/{{ server_id }}"
    method: POST
    user: "{{ hetzner_webservice_username }}"
    password: "{{ hetzner_webservice_password }}"
    force_basic_auth: yes
    body: "type=hw"
    status_code: 200
    headers:
      Content-Type: "application/x-www-form-urlencoded"
  register: reset
  delegate_to: localhost
  when:
    - not already_in_rescue


- name: Remove server from local known_hosts file
  command: "/usr/bin/ssh-keygen -R {{ hetzner_ip }}"
  register: output
  failed_when: output.rc != 0
  changed_when: '"updated" in output.stdout'
  delegate_to: localhost

- name: Pause a bit for the hardware reset to kick in
  pause: seconds=5

- name: Wait 600 seconds for port 22 to become open
  wait_for:
    port: 22
    host: '{{ hetzner_ip }}'
    delay: 10
    timeout: 600
  connection: local

- name: Copy autosetup configuration file
  template:
    src: "{{ hetzner_autosetup_file }}"
    dest: /root/autosetup.ansible
    owner: root
    group: root
    mode: 0644
  delegate_to: "{{ hetzner_ip }}"

- name: Copy postinstall file for cryptroot
  template:
    src: "{{ hetzner_postinst_file }}"
    dest: /root/post-install.ansible
    owner: root
    group: root
    mode: 0755
  delegate_to: "{{ hetzner_ip }}"
  when: hetzner_crypt_password is defined


- name: Run installimage
  command: "/root/.oldroot/nfs/install/installimage -a -c /root/autosetup.ansible {{postinst_string}}"
  environment:
    TERM: "vt100"
  register: result
  changed_when: true
  failed_when: false
  delegate_to: "{{ hetzner_ip }}"
  vars:
    postinst_string: "{% if hetzner_crypt_password is defined %}-x /root/post-install.ansible{% endif %}"

- name: Print installimage output with -v
  debug:
    var: result.stdout_lines
    verbosity: 1
  delegate_to: localhost

- name: Print installimage stderroutput with -v
  debug:
    var: result.stderr_lines
    verbosity: 1
  delegate_to: localhost

- name: Check stderr from installimage
  debug:
    msg: "Something want wrong at installimage: {{ result.stderr_lines | join('\n') }}"
  when:
    - result.stderr_lines | length > 0
    - not hetzner_image_ignore_errors
  delegate_to: localhost

### todo: add pulling of debug.log which is created by the installer for further analysis
- name: Check stdout from installimage
  fail:
    msg: "Installation failed, check log: {{ result.stdout_lines | join('\n') }}"
  when:
    - >
      result.stdout is search('An error occured while installing the new system') or
      result.stdout is search('Cancelled')
    - not hetzner_image_ignore_errors
  delegate_to: localhost

- name: Reboot server
  shell: sync && sleep 2 && shutdown -r now
  async: 1
  poll: 0
  changed_when: true
  failed_when: false
  delegate_to: "{{ hetzner_ip }}"

- name: Remove server from local known_hosts file
  command: "/usr/bin/ssh-keygen -R {{ hetzner_ip }}"
  register: output
  failed_when: output.rc != 0
  changed_when: '"updated" in output.stdout'
  delegate_to: localhost

- name: Crypt-Unlocking twice
  when: hetzner_crypt_password is defined
  block:
  ##
  ## We have to unlock twice, because of auto-relabeling there are two boots
  ##

  # wait for first reboot
  - name: Wait 600 seconds for port crypt-shell to become open
    wait_for:
      port: "{{ hetzner_crypt_network_ssh_port }}"
      host: '{{ hetzner_ip }}'
      delay: 10
      timeout: 600
    connection: local

  # Show console before auth
  - name: Read the console
    ansible.builtin.raw: |
      console_peek
    timeout: 5
    register: cryptroot_peek_reg
    delegate_to: "{{ hetzner_ip }}"
    ignore_errors: true
  - debug: var=cryptroot_peek_reg

  # this needs to be done manually, because the "console_auth" tool
  # wants interactive input and we need to fake that
  - name: Unlock cryptroot
    ansible.builtin.shell: "echo {{ hetzner_crypt_bootstrap_password }} | ssh  -o StrictHostKeyChecking=no -l root -t {{ hetzner_ip }} 'console_auth'"
    timeout: 5
    register: cryptroot_unlock_reg
    ignore_errors: true
    delegate_to: "localhost"

  # Show console after auth
  - name: Pause a bit for the hardware reset to kick in
    pause: seconds=2
  - name: Read the console
    ansible.builtin.raw: |
      console_peek
    timeout: 5
    register: cryptroot_peek_reg
    delegate_to: "{{ hetzner_ip }}"
    ignore_errors: true
  - debug: var=cryptroot_peek_reg

  - name: Pause a bit for the hardware reset to kick in
    pause: seconds=15

  # wait for second reboot
  - name: Wait 600 seconds for port crypt-shell to become open
    wait_for:
      port: "{{ hetzner_crypt_network_ssh_port }}"
      host: '{{ hetzner_ip }}'
      delay: 10
      timeout: 600
    connection: local

  # Show console before auth
  - name: Read the console
    ansible.builtin.raw: |
      console_peek
    timeout: 5
    register: cryptroot_peek_reg
    delegate_to: "{{ hetzner_ip }}"
    ignore_errors: true
  - debug: var=cryptroot_peek_reg

  # this needs to be done manually, because the "console_auth" tool
  # wants interactive input and we need to fake that
  - name: Unlock cryptroot
    ansible.builtin.shell: "echo {{ hetzner_crypt_bootstrap_password }} | ssh  -o StrictHostKeyChecking=no -l root -t {{ hetzner_ip }} 'console_auth'"
    timeout: 5
    register: cryptroot_unlock_reg
    ignore_errors: true
    delegate_to: "localhost"

  # Show console after auth
  - name: Pause a bit for the hardware reset to kick in
    pause: seconds=2
  - name: Read the console
    ansible.builtin.raw: |
      console_peek
    timeout: 5
    register: cryptroot_peek_reg
    delegate_to: "{{ hetzner_ip }}"
    ignore_errors: true
  - debug: var=cryptroot_peek_reg


- name: Wait 600 seconds for port 22 to become open
  wait_for:
    port: 22
    host: '{{ hetzner_ip }}'
    delay: 10
    timeout: 600
  connection: local

- name: "Refresh information after re-install of {{ hetzner_ip }}"
  ansible.builtin.gather_facts:
  register: host_facts
  delegate_to: "{{ hetzner_ip }}"

- name: Change luks passphrase
  when: hetzner_crypt_password is defined
  delegate_to: "{{ hetzner_ip }}"
  block:
    - name: Set fact for the LVM PVs of vg0
      set_fact:
        luks_pv: "{{ ansible_facts.lvm.pvs | dict2items | selectattr('value.vg', 'equalto', hetzner_vg_name) | map(attribute='key') | list }}"
      no_log: true

    - name: Find parent of cryptdevice
      ansible.builtin.shell:
        cmd: "lsblk -l -o path,pkname | grep {{ luks_pv[0] }} | cut -d ' ' -f 2"
        executable: /bin/bash
      when: luks_pv | length > 0
      register: luks_cryptdev_reg
      ignore_errors: true

    - set_fact:
        luks_cryptdev: "{{luks_cryptdev_reg.stdout_lines[0]}}"

    - name: Ensure the LUKS device variable is set
      fail:
        msg: "LUKS device could not be determined."
      when: luks_pv | length == 0

    - name: Add new passphrase to LUKS device
      ansible.builtin.shell:
        cmd: "echo -n '{{ hetzner_crypt_password }}' | cryptsetup luksAddKey /dev/{{ luks_cryptdev }} --key-file <(echo -n '{{ hetzner_crypt_bootstrap_password }}')"
        executable: /bin/bash
      no_log: true
      when: luks_pv | length > 0
      register: lukskey_add_reg
      ignore_errors: true

    - name: Remove old passphrase from LUKS device
      ansible.builtin.shell:
        cmd: "echo -n '{{ hetzner_crypt_bootstrap_password }}' | cryptsetup luksRemoveKey /dev/{{ luks_cryptdev }} --key-file <(echo -n '{{ hetzner_crypt_bootstrap_password }}')"
        executable: /bin/bash
      no_log: true
      when: luks_pv | length > 0
      register: lukskey_del_reg
      ignore_errors: true
